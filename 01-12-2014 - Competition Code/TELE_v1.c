


#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     rearSonar,      sensorSONAR)
#pragma config(Sensor, S3,     IRSeek,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touchBucketZero, sensorTouch)
#pragma config(Motor,  motorA,           ,             tmotorNXT, PIDControl)
#pragma config(Motor,  motorB,           ,             tmotorNXT, PIDControl)
#pragma config(Motor,  motorC,           ,             tmotorNXT, PIDControl)
#pragma config(Motor,  mtr_S1_C2_1,     Right_drive,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Left_drive,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     bucket,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    Right_Flipper,        tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    Left_Flipper,         tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*--------------------------------------------------------------------------------------------------------*\
|*                                                                                                        *|
|*                                    - Tetrix Simple Tank Drive -                                        *|
|*                                          ROBOTC on Tetrix                                              *|
|*                                                                                                        *|
|*  This program allows you to drive a robot via remote control using the ROBOTC Debugger.                *|
|*  This particular method uses "Tank Drive" where each side is controlled individually like a tank.      *|
|*                                                                                                        *|
|*                                        ROBOT CONFIGURATION                                             *|
|*    NOTES:                                                                                              *|
|*                                                                                                        *|
|*    MOTORS & SENSORS:                                                                                   *|
|*    [I/O Port]              [Name]              [Type]              [Description]                       *|
|*    Port D                  motorD              12V                 Right motor                         *|
|*    Port E                  motorE              12V                 Left motor                          *|
\*---------------------------------------------------------------------------------------------------4246-*/

#include "JoystickDriver.c"

//int checkFlippers(){
//	  // check if flippers are open.  If not, open them up //
//  	if(ServoValue[Right_Flipper] != R_Flip_Open || ServoValue[Left_Flipper] != L_Flip_Open) {
//  		servo[Right_Flipper] = R_Flip_Open;
//  		servo[Left_Flipper] = L_Flip_Open;
//  		wait1Msec(20);
//  		return TRUE;
//  	}


task main()
{
  while(true)                            // Infinite loop:
  {
    int bucketDrive;
    int bucketDump;
    int bucketDumpFromZero;
    int L_Flip_Open;
    int L_Flip_Close;
   	int R_Flip_Close;
    int R_Flip_Open;


    bucketDrive = 800;					// define bucket drive position
    //bucketDumpFromZero = 960;					// define bucket dump position for 2:1 ratio bot:  for 120 degrees from down position; 120*2= 240 degrees at the motor output; 1440 encoder counts*240degrees/360 degrees of rotation*1440 counts-->960 counts
    bucketDumpFromZero = 1440;					// define bucket dump position to be 120 degrees from down position; 3:1 gear ratio --> 360 degrees of rotation*1440 counts/revolution
    bucketDump = bucketDumpFromZero - bucketDrive;
    L_Flip_Close = 150;
    L_Flip_Open = 15;
   	R_Flip_Close = 85;
    R_Flip_Open = 230;


    getJoystickSettings(joystick);

    motor[Left_drive] =.7* joystick.joy2_y2;         // Motor D is assigned a power level equal to the right analog stick's Y-axis reading.
    motor[Right_drive] =.7* joystick.joy2_y1;         // Motor E is assigned a power level equal to the left analog stick's Y-axis reading.



    // BUTTONS TO CONTOL SERVO ARM
    // Control arm via shoulder buttons, 5 and 6... 6=up, 5=down

    if(joy1Btn(7))          // If Button 5 on controller 1 is pressed:
    {
      servo[Left_Flipper] = L_Flip_Close;      // Lower left flipper to closed position.
    }

    if(joy1Btn(5))          // If Button 7 on controller 1 is pressed:
    {
      servo[Left_Flipper] = L_Flip_Open;       // Raise left flipper to open position.
    }


  if(joy1Btn(6))          // If Button  6 on controller 1 is pressed:
    {
      servo[Right_Flipper] = R_Flip_Open;      // Raise the rigt flipper to open position.
    }

    if(joy1Btn(8))          // If Button 8 on controller 1 is pressed:
    {
      servo[Right_Flipper] = R_Flip_Close;       // Lower rigth flipper to close position.
	  }


  if(joy1Btn(4) & SensorValue(touchBucketZero)== 1)      // If the button 4 on controller 1 is pressed, bucket moves to position above ground for driving
  {

  // check if flippers are open.  If not, open them up //
  	if(ServoValue[Right_Flipper] != R_Flip_Open || ServoValue[Left_Flipper] != L_Flip_Open) {
  		servo[Right_Flipper] = R_Flip_Open;
  		servo[Left_Flipper] = L_Flip_Open;
  	}


  nMotorEncoder[bucket] = 0;
  nMotorEncoderTarget[bucket] = 800;  // target drive position
  motor[bucket] = -25;
  while(nMotorRunState[bucket] != runStateIdle)  // While Motor is still running:
		{

			if (nMotorEncoder[bucket] > 800) // wait for motor to reach a specific location
			{
  			break;
			}

  	// Do not continue.
		}
  motor[bucket] = 0;

	}
  else
	{
	motor[bucket] = 0;
	}

 if(joy1Btn(3))      // If the button 3 on controller 1 is pressed, bucket moves to position to dump blocks and returns to bucket drive postion
  {

  nMotorEncoderTarget[bucket] = 1000;  // target bucket dumping position
  motor[bucket] = -25;
  while(nMotorRunState[bucket] != runStateIdle)  // While Motor is still running, allow to go to target posititon
		{
  	// Do not continue.
		}
  motor[bucket] = 0;

  // if(SensorValue(touchBucketZero)== 0)
  // {
  nMotorEncoderTarget[bucket] = 1000;  // target bucket drive position
  motor[bucket] = 25;
  while(nMotorRunState[bucket] != runStateIdle)  // While Motor is still running, allow to go to target posititon
		{
  	// Do not continue.
		}
  motor[bucket] = 0;
//}

	}
  else
	{
	motor[bucket] = 0;
	}


 if(joy1Btn(2)& SensorValue(touchBucketZero)== 0)      // If the button 2 on controller 1 is pressed & touch sensor is not pressed :
  {

  while (SensorValue(touchBucketZero) != 1)							// bucket motor will move clockwise until touch sensor is pressed
  {
  	motor[bucket] = 25;

  }
  motor[bucket] = 0;
	}
  else
  {
  	motor[bucket] = 0;
  }

//if(joy1Btn(3)& SensorValue(touchBucketUp)== 0)      // If the button 3 on controller 1 is pressed & touch sensor is not pressed :
//  {

//  while (SensorValue(touchBucketUp) != 1)							// bucket motor will move counterclockwise until touch sensor is pressed
// {
//  	motor[bucket] = -20;

//  }
//  motor[bucket] = 0;
//	}
//  else
//  {
//  	motor[bucket] = 0;
//  }




	if(joy1Btn(1))  //FLAG motor
	{
		motor[flag] = -100;
	}
	else if(joy1Btn(1) != true)
	{
		motor[flag] = 0;
}



}

}
